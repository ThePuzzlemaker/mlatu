type (t) list {
  case nil
  case cons (t, t list)
}

instance cmp (for t. t list, t list -> ord) {
  -> xs, ys;
  match (xs)
  case cons {
    -> x, x-tail;
    match (ys)
    case cons {
      -> y, y-tail;
      match (x y cmp)
      case equal { x-tail y-tail cmp }
      case less { less }
      case more { more }
    }
    case nil { more }
  }
  case nil {
    match (ys)
    case cons { drop drop less }
    case nil { equal }
  }
}

define for-all (for t . t list, (t -> bool) -> bool) {
  -> f;
  true { f call and } fold-left
}

define for-all2 (for a b . a list, b list, (a, b -> bool) -> bool) {
  -> f;
  combine { unpair f call } for-all
}

define and-all (bool list -> bool) { true \and fold-left }

define exists (for t . t list, (t -> bool) -> bool) {
  -> f;
  true { f call or } fold-left
}

define exists2 (for a b . a list, b list, (a, b -> bool) -> bool) {
  -> f;
  combine { unpair f call } exists
}

define append (for t . t list, t list -> t list) {
  -> a, b;
  match (b)
  case nil { a }
  case cons { -> h, t; h a cons t append }
}

define append3 (for t . t list, t list, t list -> t list) { append append }

define cartesian (for a b . a list, b list -> (b a pair) list) {
  \mk-pair cartesian-with
}

define cartesian-with (for a b c . a list, b list, (a, b -> c) -> c list) {
  -> ys, f;
  { -> x; ys { x swap f call } map } map-concat
}

define concat (for t . (t list) list -> t list) { [] \append fold-left }

define concat-optionals (for t . (t optional) list -> t list) {
  [] { match case some { suffix } else {} } fold-left
}

define iter (for t +p . t list, (t -> <p>) -> <p>) {
  -> f;
  match
  case cons { -> h, t; h f call t f iter }
  case nil {}
}

define iter2 (for a b +p . a list, b list, (a, b -> <p>) -> <p>) {
  -> f;
  combine { unpair f call } iter
}

define mem (for t . t, t list -> bool) { swap -> x; { x eq } exists }

define empty (for t . t list -> bool) {
  match
  case nil { true }
  case cons { drop drop false }
}

define filter-in (for t . t list, (t -> bool) -> t list) {
  -> f;
  match
  case cons { -> h, t; t f filter-in h f call if { h swap cons } else {} }
  case nil { nil }
}

define filter-out (for t . t list, (t -> bool) -> t list) {
  -> f;
  { f call not } filter-in
}

define find (for t . t list, (t -> bool) -> t optional) { filter-in hd }

define fold-left (for a b . b list, a, (a, b -> a) -> a) {
  -> z, k;
  match
  case cons { -> h, t; t (z h k call) k fold-left }
  case nil { z }
}

define fold-right (for a b . a list, b, (a, b -> b) -> b) {
  -> z, k;
  match (init-last)
  case some { unpair z k call k fold-right }
  case none { z }
}

define nth (for t . t list, nat -> t optional) {
  -> l, n;
  match (l)
  case nil { none }
  case cons {
    -> x, xs;
    match (n)
    case zero { x some }
    case succ { -> n1; xs n1 nth }
  }
}

define get-all (for t . t list, nat list -> (t optional) list) {
  swap -> list;
  { list swap nth } map
}

define glue (for t . t list, t list, t list -> t list) { prepend append }

define hd (for t . t list -> t optional) {
  match
  case nil { none }
  case cons { drop some }
}

define hd-tl (for t . t list -> ((t list) t pair) optional) {
  match
  case nil { none }
  case cons { mk-pair some }
}

define tl-hd (for t . t list -> (t (t list) pair) optional) {
  match
  case nil { none }
  case cons { swap mk-pair some }
}

define init (for t . t list -> (t list) optional) {
  match
  case nil { none }
  case cons {
    -> h, t;
    match (t init)
    case some { -> i; h i cons some }
    case none { h nil cons some }
  }
}

define init-last (for t . t list -> (t (t list) pair) optional) {
  match
  case nil { none }
  case cons {
    -> h, t;
    match (t)
    case cons {
      -> h1, t1;
      match (t1 init-last)
      case some {
        unpair -> i, l;
        [h, h1] i append l mk-pair some
      }
      case none {
        [h] h1 mk-pair some
      }
    }
    case nil { nil h mk-pair some}
  }
}

define join (for t . (t list) list, t list -> t list) {
  -> g;
  [] { g glue } fold-left
}

define last (for t . t list -> t optional) {
  match
  case nil { none }
  case cons {
    -> h, t;
    match (t last)
    case some { some }
    case none { h some }
  }
}

define lefts (for a b . (b a either) list -> a list) { \get-left map-optionally }

define length (for t . t list -> nat) { 0 { drop 1 (+) } fold-left }

define map (for a b +p . a list, (a -> b <p>) -> b list <p>) {
  -> f;
  match
  case cons { -> h, t; (h f call) (t f map) cons }
  case nil { nil }
}

define map2 (for a b c +p . a list, b list, (a, b -> c <p>) -> c list <p>) {
  -> f;
  combine (\unpair f compose) map
}

define map-concat (for a b . a list, (a -> b list) -> b list) { map concat }

define map-index (for a b +p . a list, (a, nat -> b <p>) -> b list <p>) {
  0 MapIndex.helper
}

define map-optionally (for a b . a list, (a -> b optional) -> b list) {
  -> f;
  match
  case cons {
    swap
    match (f call)
    case some { swap f map-optionally cons }
    case none { f map-optionally }
  }
  case nil { nil }
}

define map-reduce-left (for a b . a list, (a -> b), (b, b -> b) -> b optional) {
  -> f;
  map f reduce-left
}

define map-reduce-left2 (for a b c . a list, b list, (a, b -> c), (c, c -> c) -> c optional) {
  -> f;
  map2 f reduce-left
}

define map-reduce-right (for a b . a list, (a -> b), (b, b -> b) -> b optional) {
  -> f;
  map f reduce-right
}

define map-reduce-right2 (for a b c . a list, b list, (a, b -> c), (c, c -> c) -> c optional) {
  -> f;
  map2 f reduce-right
}

define once (for t . t -> t list) { -> x; [x] }

define or-all (bool list -> bool) { true \or fold-left }

define pad-hd (for t . t list, nat, t -> t list) {
  -> list, min-length, elt;
  if (list length min-length lt) {
    list elt min-length list length - replicate prepend
  }
  else { list }
}

define pad-tl (for t . t list, nat, t -> t list) {
  -> list, min-length, elt;
  if (list length min-length lt) {
    elt min-length list length - replicate list prepend
  }
  else { list }
}

define partition (for t . t list, (t -> bool) -> t list, t list) {
  -> f;
  { f filter-in } { f filter-out } bi
}

define partition-eithers (for a b . (b a either) list -> a list, b list) {
  -> xs;
  (xs lefts) (xs rights)
}

define prepend (for t . t list, t list -> t list) { swap append }

define reduce-left (for t . t list, (t, t -> t) -> t optional) {
  -> f;
  tl-hd { unpair f fold-left } map-optional
}

define reduce-right (for t . t list, (t, t -> t) -> t optional) {
  -> f;
  init-last { unpair f fold-right } map-optional
}

define remove (for t . t list, t -> t list) { -> x; { x eq } filter-out }

define remove-nth (for t . t list, nat -> t list) {
  -> index;
  { -> x, i; if (i index eq) { [] } else { [x] } } map-index concat
}

define replicate (for t . t, nat -> t list) {
  -> value, count;
  if (count 0 le) { [] }
  else { value (count 1 -) replicate value suffix }
}

define rev (for t . t list -> t list) {
  match
  case cons { rev swap suffix }
  case nil { nil }
}

define rights (for a b . (b a either) list -> b list) {
  \get-right map-optionally
}

define suffix (for t . t list, t -> t list) { once append }

define surround (for t . t list, t list, t list -> t list) {
  -> x;
  prepend x append
}

define tl (for t . t list -> (t list) optional) {
  match
  case nil { none }
  case cons { swap drop some }
}

define split (for a b . (b a pair) list -> a list, b list) {
  match
  case cons {
    -> h, t;
    h unpair -> m, n;
    t split -> ms, ns;
    m ms cons n ns cons
  }
  case nil { [] [] }
}

define combine (for a b . a list, b list -> (b a pair) list) {
  -> a, b;
  match (a)
  case cons {
    -> x1, x2;
    match (b)
    case cons {
      -> y1, y2;
      x1 y1 mk-pair x2 y2 combine cons
    }
    case nil { [] }
  }
  case nil { [] }
}

define MapIndex.helper (for a b +p . a list, (a, nat -> b <p>), nat -> b list <p>) {
  -> f, i;
  match
  case cons { -> h, t; h i f call t f i 1 + helper cons }
  case nil { [] }
}
