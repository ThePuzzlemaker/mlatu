type Bool:
  case false
  case true

trait not[T] (T -> T)

instance not (Bool -> Bool):
  if:
    false
  else:
    true

instance not (Int -> Int) { _::mlatu::not_int64 }

// Strict intersection.
trait & [T] (T, T -> T)

about &:
  operator:
    right 3

instance & (Bool, Bool -> Bool):
  -> x, y;
  if (x):
    y
  else:
    false

instance & (Int, Int -> Int) { _::mlatu::and_int64 }

// Lazy intersection.
trait && [T] (T, (-> T) -> T)

about &&:
  operator:
    right 3

instance && (Bool, (-> Bool) -> Bool):
  -> x, y;
  if (x):
    y call
  else:
    false

// Strict union.
trait | [T] (T, T -> T)

about |:
  operator:
    right 2

instance | (Bool, Bool -> Bool):
  -> x, y;
  if (x):
    true
  else:
    y

instance | (Int, Int -> Int) { _::mlatu::or_int64 }

// Lazy union.
trait || [T] (T, (-> T) -> T)

about ||:
  operator:
    right 2

instance || (Bool, (-> Bool) -> Bool):
  -> x, y;
  if (x):
    true
  else:
    y call

// Strict difference.
trait ~ [A] (A, A -> A)

about ~:
  operator:
    5

instance ~ (Bool, Bool -> Bool):
  swap
  if { not }

instance ~ (Int, Int -> Int) { _::mlatu::xor_int64 }

// Strict implication.
trait --> [T] (T, T -> T)

about -->:
  operator:
    right 1

instance --> (Bool, Bool -> Bool):
  -> a, b;
  if (a) { b } else { true }

instance --> (Int, Int -> Int) { -> a, b; a not | b }

// Lazy implication.
define ---> (Bool, (-> Bool) -> Bool):
  -> a, b;
  if (a) { b call } else { true }

about --->:
  operator:
    right 1

define until[R...] (R..., (R... -> R..., Bool) -> R...):
  -> f;
  if (f call not):
    f until

// do (while) { ... }
define while[R...] (R..., (R... -> R..., Bool) -> R...):
  -> f;
  if (f call):
    f while

